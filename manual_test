Minishell - Manual & Automated Test Suite
=========================================

Descripción
-----------
Este archivo contiene una colección grande de pruebas manuales y ejemplos de
scripts que puedes ejecutar para verificar el comportamiento de tu `minishell`.
Incluye casos para: builtins, redirecciones, pipes, expansions, señales, heredocs,
comportamiento interactivo esperado y algunos tests automáticos sencillos.

Cómo usar
---------
- Asegúrate de compilar tu proyecto con `make` o `make bonus` según corresponda.
- Coloca el ejecutable `minishell` en la carpeta del proyecto (raíz) o actualiza
  las rutas en los scripts más abajo.
- Muchos tests están diseñados para ejecutarse en una terminal interactiva; algunos
  otros pueden ejecutarse en batch redirigiendo input desde un archivo.

Estructura del archivo
----------------------
- Sección A: quick smoke tests (rápidos)
- Sección B: builtins (varias combinaciones)
- Sección C: redirecciones y pipelines
- Sección D: heredoc (<<) y EOF behaviors
- Sección E: expansión de variables y $? checks
- Sección F: señales (Ctrl-C, Ctrl-D, Ctrl-\) pruebas manuales)
- Sección G: tests automáticos (pequeño script `run_tests.sh` básico)

------
Sección A - Smoke tests
------

1) Ejecutable y prompt

	./minishell
	-> Debe mostrar un prompt y aceptar comandos básicos: `echo hola` -> `hola`

2) PATH lookup

	/bin/echo hola
	-> Debe ejecutar /bin/echo y mostrar `hola`.

3) Comando no encontrado

	comando_que_no_existe
	-> Debe imprimir algo tipo: `minishell: comando_que_no_existe: command not found`

------
Sección B - Builtins
------

echo tests

1) echo simple
	echo hola
	-> `hola`\n

2) echo -n
	echo -n hola
	-> `hola` sin newline final

3) echo con variables
	VAR=abc; export VAR
	echo $VAR
	-> `abc`

cd / pwd tests

1) cd a ruta absoluta
	mkdir -p /tmp/minitest && cd /tmp/minitest && /path/to/minishell
	cd /tmp/minitest && pwd
	-> debe mostrar `/tmp/minitest`

2) cd relativo
	mkdir -p /tmp/minitest/sub && cd /tmp/minitest && cd sub && pwd

export / unset / env

1) export simple
	export FOO=BAR
	env | grep FOO

2) unset
	unset FOO
	env | grep FOO  # no debe mostrar nada

3) export con argumentos múltiples
	export A=1 B=2 C=3
	env | grep -E 'A=|B=|C='

exit

1) exit sin args -> termina con status 0
2) exit 42 -> termina con status 42

------
Sección C - Redirecciones y pipes
------

1) Simple output redirection
	echo hola > /tmp/minitest/out.txt
	cat /tmp/minitest/out.txt  # contiene `hola`

2) Append redirection
	echo a > /tmp/minitest/out.txt
	echo b >> /tmp/minitest/out.txt
	cat /tmp/minitest/out.txt  # contiene `a\nb\n`

3) Input redirection
	printf "hola\n" > /tmp/minitest/in.txt
	cat < /tmp/minitest/in.txt  # imprime `hola`

4) Pipes simples
	echo "foo" | wc -c  # devuelve byte count

5) Pipes múltiples
	echo -e "one\ntwo\nthree" | grep t | wc -l  # debe contar 2

6) Combinación redirección + pipe
	echo -e "1\n2" | cat > /tmp/minitest/p && cat /tmp/minitest/p | wc -l

------
Sección D - Heredoc (<<)
------

1) Heredoc básico
	cat << EOF
	hola
	EOF

2) Heredoc con variable (sin expandir si está en single quotes)
	DELIM=END
	cat << $DELIM
	$DELIM
	END

3) Heredoc terminadores y no actualización del historial

------
Sección E - Expansión y $? checks
------

1) Expansión simple
	export A=abc
	echo $A  # -> abc

2) Expansión $?
	false
	echo $?  # -> 1
	true
	echo $?  # -> 0

3) Expansión en pipeline
	false | true
	echo $?  # comportamiento: estado del último command en la pipeline

------
Sección F - Señales (manuales)
------

1) Ctrl-C en prompt
	- Esperado: imprime nueva línea y muestra un nuevo prompt (status 130 o 0 segun diseño)

2) Ctrl-D en prompt
	- Esperado: shell sale

3) Ctrl-\ (SIGQUIT)
	- Esperado: no debe cerrar el shell

Sección G - Tests automáticos básicos
------

Abajo hay un pequeño script `run_tests.sh` que automatiza varios tests en modo no interactivo
usando heredocs y comparando la salida esperada. No cubre todo, pero es un buen inicio.

Guarda este archivo como `run_tests.sh` y dale permiso de ejecución (chmod +x run_tests.sh).

---- run_tests.sh ----
#!/usr/bin/env bash
set -euo pipefail

MINI=./minishell
TMPDIR=./.minitest
mkdir -p "$TMPDIR"

assert_eq() {
  local got expected name
  name="$1"; got="$2"; expected="$3"
  if [ "$got" = "$expected" ]; then
	 printf "[OK] %s\n" "$name"
  else
	 printf "[FAIL] %s\n  expected: %s\n  got:      %s\n" "$name" "$expected" "$got"
	 exit 2
  fi
}

echo "Running basic non-interactive tests..."

# Test 1: echo
out1=$(printf "echo hello\nexit\n" | "$MINI" | sed -n '1p' || true)
assert_eq "echo_hello" "$out1" "hello"

# Test 2: exit code
rc=$(printf "false\nexit\n" | "$MINI" >/dev/null 2>&1; echo $?)
assert_eq "exit_code_false" "$rc" "1"

echo "All automated tests passed (basic)"

---- end run_tests.sh ----

Notas y consejos
---------------
- Algunos tests requieren interacción manual (señales, edición de línea). Usa una
  terminal separada y ejecuta comandos manuales cuando sea necesario.
- Para bugs relacionados con memoria, usa valgrind (si está disponible):
  valgrind --leak-check=full ./minishell
- Si tu proyecto usa readline, algunas fugas pueden venir de readline; revisa la
  documentación del enunciado sobre qué fugas son tolerables.

Fin del documento de pruebas.

